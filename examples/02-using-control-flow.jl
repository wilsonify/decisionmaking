import Base.Iterators: product
import IterTools: subsets

# We can control the flow of our programs using conditional evaluation and loops.
# This section provides some of the syntax used in the book.


#Conditional evaluation will check the value of a Boolean expression and then
#evaluate the appropriate block of code. One of the most common ways to do this
#is with an if statement.
x = 10
y = 24132

if x < y
    println("run this if x < y")
elseif x > y
    println("run this if x > y")
else
    println("run this if x == y")
end


#We can also use the ternary operator with its question mark and colon syntax.
#It checks the Boolean expression before the question mark. If the expression
#evaluates to true, then it returns what comes before the colon; otherwise it returns
#what comes after the colon.

f(x) = x > 0 ? x : 0
@show f(-10) == 0
@show f(10) == 10


#A loop allows for repeated evaluation of expressions. One type of loop is the while
#loop. It repeatedly evaluates a block of expressions until the specified condition
#after the while keyword is met. The following example sums the values in the
#array x .

X = [1, 2, 3, 4, 6, 8, 11, 13, 16, 18]
s = 0
while !isempty(X)
    @show pop!(X)
end


#Another type of loop is the for loop. It uses the for keyword. The following
#example will also sum over the values in the array x but will not modify x .

X = [1, 2, 3, 4, 6, 8, 11, 13, 16, 18]
s = 0
for i = 1:length(X)
    @show X[i]
end
@show s


#The = can be substituted with in or âˆˆ . The following code block is equivalent.

X = [1, 2, 3, 4, 6, 8, 11, 13, 16, 18]
s = 0
for y in X
    @show y
end
@show s == sum(X)


#We can iterate over collections in contexts such as for loops and array comprehensions. To demonstrate various iterators, we will use the collect function, which
#returns an array of all items generated by an iterator:

X = ["feed", "sing", "ignore"]

@show(collect(enumerate(X)))
@show(collect(eachindex(X)))
Y = [-5, -0.5, 0.0]
@show(collect(zip(X, Y)))

@show(collect(subsets(X)))

@show(collect(eachindex(X)))
Z = [1 2; 3 4; 5 6]


# iterate over Cartesian product of multiple iterators
@show(collect(product(X, Y)))
