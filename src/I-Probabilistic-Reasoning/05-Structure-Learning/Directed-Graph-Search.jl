struct K2Search
    """
    K2 search of the
space of directed acyclic graphs using a specified variable ordering.
This variable ordering imposes a
topological ordering in the resulting graph. The fit function takes
an ordered list variables vars and
a data set D. The method starts
with an empty graph and iteratively adds the next parent that
maximally improves the Bayesian
score.
    """
    ordering::Vector{Int} # variable ordering
end
function fit(method::K2Search, vars, D)
    G = SimpleDiGraph(length(vars))
    for (k, i) in enumerate(method.ordering[2:end])
        y = bayesian_score(vars, G, D)
        while true
            y_best, j_best = -Inf, 0
            for j in method.ordering[1:k]
                if !has_edge(G, j, i)
                    add_edge!(G, j, i)
                    y′ = bayesian_score(vars, G, D)
                    if y′ > y_best
                        y_best, j_best = y′, j
                    end
                    rem_edge!(G, j, i)
                end
            end
            if y_best > y
                y = y_best
                add_edge!(G, j_best, i)
            else
                break
            end
        end
    end
    return G
end


struct LocalDirectedGraphSearch
    """
    Local directed
graph search, which starts with
an initial directed graph G and
opportunistically moves to a random graph neighbor whenever its
Bayesian score is greater. It repeats
this process for k_max iterations.
Random graph neighbors are generated by either adding or removing a single edge. This algorithm
can be extended to include reversing the direction of an edge. Edge
addition can result in a graph with
cycles, in which case we assign a
score of −∞.
    """
    G::Any # initial graph
    k_max::Any # number of iterations
end
function rand_graph_neighbor(G)
    n = nv(G)
    i = rand(1:n)
    j = mod1(i + rand(2:n) - 1, n)
    G′ = copy(G)
    has_edge(G, i, j) ? rem_edge!(G′, i, j) : add_edge!(G′, i, j)
    return G′
end
function fit(method::LocalDirectedGraphSearch, vars, D)
    G = method.G
    y = bayesian_score(vars, G, D)
    for k = 1:method.k_max
        G′ = rand_graph_neighbor(G)
        y′ = is_cyclic(G′) ? -Inf : bayesian_score(vars, G′, D)
        if y′ > y
            y, G = y′, G′
        end
    end
    return G
end
