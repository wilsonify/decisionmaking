Control Flow
We can control the flow of our programs using conditional evaluation and loops.
This section provides some of the syntax used in the book.
G.3.1 Conditional Evaluation
Conditional evaluation will check the value of a Boolean expression and then
evaluate the appropriate block of code. One of the most common ways to do this
is with an if statement.
if x < y
# run this if x < y
elseif x > y
# run this if x > y
else
# run this if x == y
end
We can also use the ternary operator with its question mark and colon syntax.
It checks the Boolean expression before the question mark. If the expression
evaluates to true, then it returns what comes before the colon; otherwise it returns
what comes after the colon.
julia> f(x) = x > 0 ? x : 0;
julia> f(-10)
0
julia> f(10)
10

G.3.2 Loops
A loop allows for repeated evaluation of expressions. One type of loop is the while
loop. It repeatedly evaluates a block of expressions until the specified condition
after the while keyword is met. The following example sums the values in the
array x .
X = [1, 2, 3, 4, 6, 8, 11, 13, 16, 18]
s = 0
while !isempty(X)
s += pop!(X)
end
Another type of loop is the for loop. It uses the for keyword. The following
example will also sum over the values in the array x but will not modify x .
X = [1, 2, 3, 4, 6, 8, 11, 13, 16, 18]
s = 0
for i = 1:length(X)
s += X[i]
end
The = can be substituted with in or ∈ . The following code block is equivalent.
X = [1, 2, 3, 4, 6, 8, 11, 13, 16, 18]
s = 0
for y in X
s += y
end
G.3.3 Iterators
We can iterate over collections in contexts such as for loops and array comprehen-
sions. To demonstrate various iterators, we will use the collect function, which
returns an array of all items generated by an iterator:
julia> X = ["feed", "sing", "ignore"];
julia> collect(enumerate(X)) # return the count and the element
3-element Vector{Tuple{Int64, String}}:
(1, "feed")
(2, "sing")
(3, "ignore")
julia> collect(eachindex(X)) # equivalent to 1:length(X)
3-element Vector{Int64}:

1
2
3
julia> Y = [-5, -0.5, 0];
julia> collect(zip(X, Y))
# iterate over multiple iterators simultaneously
3-element Vector{Tuple{String, Float64}}:
("feed", -5.0)
("sing", -0.5)
("ignore", 0.0)
julia> import IterTools: subsets
julia> collect(subsets(X))
# iterate over all subsets
8-element Vector{Vector{String}}:
[]
["feed"]
["sing"]
["feed", "sing"]
["ignore"]
["feed", "ignore"]
["sing", "ignore"]
["feed", "sing", "ignore"]
julia> collect(eachindex(X)) # iterate over indices into a collection
3-element Vector{Int64}:
1
2
3
julia> Z = [1 2; 3 4; 5 6];
julia> import Base.Iterators: product
julia> collect(product(X,Y)) # iterate over Cartesian product of multiple iterators
3×3 Matrix{Tuple{String, Float64}}:
("feed", -5.0)
("feed", -0.5)
("feed", 0.0)
("sing", -5.0)
("sing", -0.5)
("sing", 0.0)
("ignore", -5.0) ("ignore", -0.5) ("ignore", 0.0)

